#!/usr/bin/env python3
"""
Optical Pumping Simulation for Helium-3 by PJ Nacher
Translated from Fortran, J. Maxwell 2025

Requires paras.dat parameters and He3.dat spectrum files.
He3.dat is generated by HeSpectra. Must be renamed to He3.dat from He3minus.dat or He3plus.dat.
"""

import numpy as np
import os
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec


class OpticalPumpingSimulation:
    def __init__(self):
        # Physical constants
        self.aS = -6739.701177e-3 * (2.0 / 3.0)  # from Rosner70 (*2/3)
        self.muB = 13996.24189e-3  # Bohr magneton in GHz/T ie µB/hbar from DrakeHB
        self.gsS = 2.002237319
        self.gi = 0.0023174823
        self.Grad = 1 / 0.9785e-7  # P state radiative decay rate

        # Physical constants for calculations
        self.hnu = 6.62607e-34 * 2.99792e8 / 1.0829e-6  # hc/lambda from CODATA www NIST

        # Common variables
        self.E3 = np.zeros((6, 6))
        self.F3 = np.zeros((6, 6))
        self.L3 = np.zeros(6)
        self.cp = 0.0
        self.cm = 0.0
        self.sp = 0.0
        self.sm = 0.0

    def ensure_output_directory(self, output_path):
        """Create output directory if it doesn't exist"""
        if not os.path.exists(output_path):
            os.makedirs(output_path)
            print(f"Created output directory: {output_path}")

    def read_parameters(self, path='./'):
        """Read input parameters from paras.dat file"""
        params_file = os.path.join(path, 'paras.dat')

        try:
            with open(params_file, 'r') as f:
                lines = f.readlines()

            # Extract first value from each line (rest of line ignored)
            field = float(lines[0].split()[0])  # B field value (T)
            pressure = float(lines[1].split()[0])  # pressure (mbar)
            wlas = float(lines[2].split()[0])  # total laser power in cell (W)
            mmlas = float(lines[3].split()[0])  # laser beam diameter (mm)
            freq = float(lines[4].split()[0])  # laser frequency (GHz)
            mmcell = float(lines[5].split()[0])  # cell internal diameter (mm)
            lcell = float(lines[6].split()[0])  # cell internal length (mm)
            nm = float(lines[7].split()[0])  # metastable density (at/cc)

            return {
                'field': field, 'pressure': pressure, 'wlas': wlas, 'mmlas': mmlas,
                'freq': freq, 'mmcell': mmcell, 'lcell': lcell, 'nm': nm
            }

        except FileNotFoundError:
            print(f"Parameter file {params_file} not found. Using default values.")
            return {
                'field': 1.0, 'pressure': 1.0, 'wlas': 1.0, 'mmlas': 10.0,
                'freq': 1000.0, 'mmcell': 20.0, 'lcell': 100.0, 'nm': 1e12
            }

    def read_he3_data(self, path='./', freq=1000.0):
        """Read transition data from He3.dat file"""
        he3_file = os.path.join(path, 'He3.dat')
        pump_lines = np.zeros(6)
        field_from_file = 0.0

        try:
            with open(he3_file, 'r') as f:
                for line in f:
                    try:
                        parts = line.split()
                        if len(parts) >= 4:
                            field_from_file = float(parts[0])
                            freq_line = float(parts[1])
                            force_osc = float(parts[2])
                            ia = int(parts[3]) - 1  # Convert to 0-based indexing

                            if 0 <= ia < 6:
                                pump_lines[ia] += np.exp(-(freq - freq_line) ** 2 / 1.19 ** 2) * force_osc
                    except (ValueError, IndexError):
                        continue

        except FileNotFoundError:
            print(f"He3 data file {he3_file} not found. Using default values.")
            pump_lines = np.ones(6) * 0.1
            field_from_file = 1.0

        return pump_lines, field_from_file

    def sort_transitions_by_energy(self, pump_lines, field):
        """Sort transitions by energies according to table 12 EPJD paper"""
        pump_lines = pump_lines.copy()

        if field >= 0.1619:
            pump_lines[4], pump_lines[3] = pump_lines[3], pump_lines[4]

        if field >= 4.716:
            pump_lines[3], pump_lines[2] = pump_lines[2], pump_lines[3]

        return pump_lines

    def mkmatechB(self):
        """Compute exchange matrices for equations (18) and (21)"""
        # Order of ai is the increasing order of energies at low field (<0.16 T)
        # Matrices from 'Zeeman' EPJD 21 (2002) page 54

        self.E3.fill(0.0)
        self.F3.fill(0.0)
        self.L3.fill(0.0)

        # Build E3 matrix
        self.E3[0, 0] = 1.0
        self.E3[0, 1] = self.cm
        self.E3[0, 4] = self.sm
        self.E3[1, 0] = self.cm
        self.E3[1, 1] = self.cm * self.cm + self.sm * self.sm
        self.E3[1, 2] = self.cp * self.sm
        self.E3[1, 4] = 2 * self.cm * self.sm
        self.E3[1, 5] = self.sp * self.sm
        self.E3[2, 1] = self.cp * self.sm
        self.E3[2, 2] = self.cp * self.cp + self.sp * self.sp
        self.E3[2, 3] = self.sp
        self.E3[2, 4] = self.cp * self.cm
        self.E3[2, 5] = 2 * self.cp * self.sp
        self.E3[3, 2] = self.sp
        self.E3[3, 3] = 1.0
        self.E3[3, 5] = self.cp
        self.E3[4, 0] = self.sm
        self.E3[4, 1] = 2 * self.cm * self.sm
        self.E3[4, 2] = self.cp * self.cm
        self.E3[4, 4] = self.cm * self.cm + self.sm * self.sm
        self.E3[4, 5] = self.cm * self.sp
        self.E3[5, 1] = self.sp * self.sm
        self.E3[5, 2] = 2 * self.cp * self.sp
        self.E3[5, 3] = self.cp
        self.E3[5, 4] = self.cm * self.sp
        self.E3[5, 5] = self.cp * self.cp + self.sp * self.sp

        self.E3 /= 2.0

        # Build F3 matrix
        self.F3[0, 0] = -1.0
        self.F3[0, 1] = -self.cm
        self.F3[0, 4] = -self.sm
        self.F3[1, 0] = self.cm
        self.F3[1, 1] = self.cm * self.cm - self.sm * self.sm
        self.F3[1, 2] = -self.cp * self.sm
        self.F3[1, 5] = -self.sp * self.sm
        self.F3[2, 1] = self.cp * self.sm
        self.F3[2, 2] = self.cp * self.cp - self.sp * self.sp
        self.F3[2, 3] = -self.sp
        self.F3[2, 4] = self.cp * self.cm
        self.F3[3, 2] = self.sp
        self.F3[3, 3] = 1.0
        self.F3[3, 5] = self.cp
        self.F3[4, 0] = self.sm
        self.F3[4, 2] = -self.cp * self.cm
        self.F3[4, 4] = -self.cm * self.cm + self.sm * self.sm
        self.F3[4, 5] = -self.cm * self.sp
        self.F3[5, 1] = self.sp * self.sm
        self.F3[5, 3] = -self.cp
        self.F3[5, 4] = self.cm * self.sp
        self.F3[5, 5] = -self.cp * self.cp + self.sp * self.sp

        self.F3 /= 2.0

        # Build L3 vector
        self.L3[0] = -1.0
        self.L3[1] = self.cm - self.sm
        self.L3[2] = self.cp - self.sp
        self.L3[3] = 1.0
        self.L3[4] = self.sm - self.cm
        self.L3[5] = self.sp - self.cp

    def compute_s_levels(self, field):
        """Compute S levels in magnetic field B"""
        b = -self.muB * field * self.gsS / self.aS
        eps = self.gi / 2 / self.gsS

        # Compute energy levels
        W3pj6 = -(1 + 2 * b + np.sqrt(
            9 + 4 * b + 4 * b ** 2 - 8 * b * eps - 16 * b ** 2 * eps * (1 - eps))) * self.aS / 4
        W3pj5 = -(1 - 2 * b + np.sqrt(
            9 - 4 * b + 4 * b ** 2 + 8 * b * eps - 16 * b ** 2 * eps * (1 - eps))) * self.aS / 4

        thp = -np.arctan(np.sqrt(2.0) * (W3pj6 / self.aS + 0.5 + b * (1 - eps)))
        thm = -np.arctan(np.sqrt(2.0) * (W3pj5 / self.aS - b * eps))

        self.cp = np.cos(thp) ** 2
        self.sp = 1.0 - self.cp
        self.cm = np.cos(thm) ** 2
        self.sm = 1.0 - self.cm

        return b

    def run_simulation(self, input_path='./', output_path='./output'):
        """Main simulation loop"""
        print('Version Feb 2008')

        # Ensure output directory exists
        self.ensure_output_directory(output_path)

        # Read input parameters
        params = self.read_parameters(input_path)

        print(f"     field: {params['field']:.3f}")
        print(f"  pressure: {params['pressure']:.3f}")
        print(f"      Wlas: {params['wlas']:.3f}")
        print(f"     mmlas: {params['mmlas']:.3f}")
        print(f"      freq: {params['freq']:.3f}")
        print(f"    mmcell: {params['mmcell']:.3f}")
        print(f"     Lcell: {params['lcell']:.1f}")
        print(f"        nm: {params['nm']:.3e}")

        # Read He3 transition data
        pump_lines, field_from_file = self.read_he3_data(input_path, params['freq'])
        print(f" B from He3.dat: {field_from_file:.3f}")

        # Sort transitions by energy
        pump_lines = self.sort_transitions_by_energy(pump_lines, params['field'])
        sum_pl = np.sum(pump_lines)

        # Initialize various parameters
        slas = np.pi * (params['mmlas'] / 10.0) ** 2 / 4.0
        wparcm2 = params['wlas'] / slas
        ge = (760 * params['pressure'] / 1013.0) / 2e-7  # tau_e = 2e-7 s/torr and pressure is in mbar
        gps_ge = (wparcm2 * 1e4) * 3706.4 / ge  # pump rate/exchange rate in S state, from eq (16)
        grads_ge = self.Grad / ge  # decay rate P state/exchange rate S state
        n3 = (760 * params['pressure'] / 1013.0) * (
                273.0 / 300.0) * 3.54e16  # Conversion of filling pressure to density in at/cc

        # Compute S levels in magnetic field B
        b = self.compute_s_levels(params['field'])
        self.mkmatechB()  # Compute exchange matrices for eqs (18) and (21)

        # Relaxation rate (set to 0 in original code)
        grs = 0.0  # Relaxation rate of 23S
        grs_ge = grs / ge

        # Prepare output file in the output directory
        output_file = os.path.join(output_path, 'OPresvsM.dat')
        results = []

        # Loop on M values
        m_values = np.arange(-0.99, 1.0, 0.01)

        for M in m_values:
            facabs = 1.0  # absorption of pump reduces power in cell by factor facabs iteratively found

            # Single iteration (could be made iterative)
            for iteration in range(1):
                # Fill U according to eq (18)
                U = np.zeros((6, 6))
                for il in range(6):
                    for ic in range(6):
                        U[il, ic] = self.E3[il, ic] + M * self.F3[il, ic]

                # Subtract identity matrix
                for i in range(6):
                    U[i, i] -= 1.0

                # Fill U according to eq (17) (relaxation of eq (19) assumed negligible for simplicity)
                for il in range(6):
                    for ip in range(6):
                        U[il, ip] += (3 * grads_ge * pump_lines[ip] * gps_ge * facabs /
                                      (sum_pl * gps_ge * facabs + 18 * grads_ge) +
                                      pump_lines[il] * gps_ge * facabs * pump_lines[ip] * gps_ge * facabs /
                                      (sum_pl * gps_ge * facabs + 18 * grads_ge))

                for ip in range(6):
                    U[ip, ip] -= pump_lines[ip] * gps_ge

                # Add relaxation terms
                for il in range(6):
                    for ic in range(6):
                        U[il, ic] += grs_ge / 6.0
                    U[il, il] -= grs_ge

                # Find kernel of U using SVD
                try:
                    u_svd, w, vt = np.linalg.svd(U)
                    v = vt.T

                    # Find minimum eigenvalue
                    imin = np.argmin(np.abs(w))

                    # Normalize eigenvector
                    som = np.sum(v[:, imin])
                    if som != 0:
                        v[:, imin] /= som

                    # Compute population in P state according to eq (7)
                    pop_p = np.dot(pump_lines, v[:, imin])
                    pop_p = 18 * pop_p / (sum_pl + 18 * grads_ge / gps_ge)

                    # Calculate absorption per cm (missing factor facabs added September 2006)
                    absparcm = (pop_p * params['nm'] * self.Grad * self.hnu) / (facabs * wparcm2)

                    # Pump intensity reduction factor due to absorption
                    facabs = (np.exp(-absparcm * params['lcell'] / 2) +
                              np.exp(-absparcm * 3 * params['lcell'] / 2)) / 2

                except np.linalg.LinAlgError:
                    # Handle singular matrix case
                    v = np.eye(6)
                    imin = 0
                    pop_p = 0.0
                    absparcm = 0.0
                    facabs = 1.0

            # Compute <I> in S state according to eq 21
            av_i = np.dot(v[:, imin], self.L3)

            # Calculate various output quantities
            mdot = ((av_i - M) * ge * (params['nm'] / n3) *
                    (params['mmlas'] / params['mmcell']) ** 2)  # from eq (20), with fraction of cell covered, no relax

            dm_f_par_phot_abs = ((av_i - M) * ge / 2) / (
                    pop_p * self.Grad)  # Quantum efficiency for uniform OP conditions in pumped fraction

            # Store results
            result = {
                'M': M,
                'GpsGe': gps_ge,
                'MstarminM': av_i - M,
                'Mdot': mdot,
                'a1': v[0, imin],
                'a2': v[1, imin],
                'a3': v[2, imin],
                'a4': v[4, imin],  # Note: indices 4 and 5 are swapped in output
                'a5': v[3, imin],
                'a6': v[5, imin],
                'Wpercm2': wparcm2,
                'Tpump': np.exp(-absparcm * 2 * params['lcell']),
                'abspercm': absparcm,
                'b': pop_p,
                'QE': dm_f_par_phot_abs
            }
            results.append(result)

        # Write results to file in output directory
        with open(output_file, 'w') as f:
            f.write(
                f"{'M':>15}{'GpsGe':>15}{'MstarminM':>15}{'Mdot':>15}{'a1':>15}{'a2':>15}{'a3':>15}{'a4':>15}{'a5':>15}{'a6':>15}{'Wpercm2':>15}{'Tpump':>15}{'abspercm':>15}{'b':>15}{'QE':>15}\n")
            for result in results:
                f.write(f"{result['M']:15.7f}{result['GpsGe']:15.7f}{result['MstarminM']:15.7f}{result['Mdot']:15.7f}")
                f.write(
                    f"{result['a1']:15.7f}{result['a2']:15.7f}{result['a3']:15.7f}{result['a4']:15.7f}{result['a5']:15.7f}{result['a6']:15.7f}")
                f.write(
                    f"{result['Wpercm2']:15.7f}{result['Tpump']:15.7f}{result['abspercm']:15.7f}{result['b']:15.7f}{result['QE']:15.7f}\n")

        print(f"Results written to {output_file}")
        return results

    def plot_results(self, results, save_plots=True, output_path='./output'):
        """
        Plot the simulation results with multiple subplots showing key parameters

        Parameters:
        -----------
        results : list
            List of result dictionaries from run_simulation()
        save_plots : bool
            Whether to save plots to files
        output_path : str
            Directory to save plots
        """
        if not results:
            print("No results to plot")
            return

        # Ensure output directory exists
        if save_plots:
            self.ensure_output_directory(output_path)

        # Extract data for plotting
        M_values = [r['M'] for r in results]
        mstar_min_m = [r['MstarminM'] for r in results]
        mdot = [r['Mdot'] for r in results]
        a_coeffs = {
            'a1': [r['a1'] for r in results],
            'a2': [r['a2'] for r in results],
            'a3': [r['a3'] for r in results],
            'a4': [r['a4'] for r in results],
            'a5': [r['a5'] for r in results],
            'a6': [r['a6'] for r in results]
        }
        tpump = [r['Tpump'] for r in results]
        abspercm = [r['abspercm'] for r in results]
        qe = [r['QE'] for r in results]

        # Create figure with subplots
        fig = plt.figure(figsize=(15, 12))
        gs = GridSpec(3, 3, figure=fig, hspace=0.3, wspace=0.3)

        # Plot 1: M* - M vs M (Nuclear polarization buildup)
        ax1 = fig.add_subplot(gs[0, 0])
        ax1.plot(M_values, mstar_min_m, 'b-', linewidth=2)
        ax1.set_xlabel('M (Nuclear Polarization)')
        ax1.set_ylabel('M* - M')
        ax1.set_title('Nuclear Polarization Buildup')
        ax1.grid(True, alpha=0.3)
        ax1.axhline(y=0, color='k', linestyle='--', alpha=0.5)

        # Plot 2: Polarization rate (Mdot) vs M
        ax2 = fig.add_subplot(gs[0, 1])
        ax2.plot(M_values, mdot, 'r-', linewidth=2)
        ax2.set_xlabel('M (Nuclear Polarization)')
        ax2.set_ylabel('Ṁ (Polarization Rate)')
        ax2.set_title('Nuclear Polarization Rate')
        ax2.grid(True, alpha=0.3)
        ax2.axhline(y=0, color='k', linestyle='--', alpha=0.5)

        # Plot 3: Population coefficients a1-a6
        ax3 = fig.add_subplot(gs[0, 2])
        colors = ['blue', 'red', 'green', 'orange', 'purple', 'brown']
        for i, (label, values) in enumerate(a_coeffs.items()):
            ax3.plot(M_values, values, color=colors[i], label=label, linewidth=1.5)
        ax3.set_xlabel('M (Nuclear Polarization)')
        ax3.set_ylabel('Population Coefficients')
        ax3.set_title('Sublevel Populations')
        ax3.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
        ax3.grid(True, alpha=0.3)

        # Plot 4: Pump transmission vs M
        ax4 = fig.add_subplot(gs[1, 0])
        ax4.plot(M_values, tpump, 'g-', linewidth=2)
        ax4.set_xlabel('M (Nuclear Polarization)')
        ax4.set_ylabel('Pump Transmission')
        ax4.set_title('Laser Transmission Through Cell')
        ax4.grid(True, alpha=0.3)
        ax4.set_ylim(0, 1)

        # Plot 5: Absorption coefficient vs M
        ax5 = fig.add_subplot(gs[1, 1])
        ax5.semilogy(M_values, np.maximum(abspercm, 1e-10), 'c-', linewidth=2)
        ax5.set_xlabel('M (Nuclear Polarization)')
        ax5.set_ylabel('Absorption Coefficient (cm⁻¹)')
        ax5.set_title('Optical Absorption')
        ax5.grid(True, alpha=0.3)

        # Plot 6: Quantum efficiency vs M
        ax6 = fig.add_subplot(gs[1, 2])
        # Handle potential division by zero or invalid values
        qe_clean = [q if np.isfinite(q) and abs(q) < 1e10 else 0 for q in qe]
        ax6.plot(M_values, qe_clean, 'm-', linewidth=2)
        ax6.set_xlabel('M (Nuclear Polarization)')
        ax6.set_ylabel('Quantum Efficiency')
        ax6.set_title('Optical Pumping Efficiency')
        ax6.grid(True, alpha=0.3)

        # Plot 7: Phase space plot (Mdot vs M)
        ax7 = fig.add_subplot(gs[2, 0])
        ax7.plot(M_values, mdot, 'k-', linewidth=2)
        ax7.fill_between(M_values, 0, mdot, alpha=0.3, color='gray')
        ax7.set_xlabel('M (Nuclear Polarization)')
        ax7.set_ylabel('Ṁ (Polarization Rate)')
        ax7.set_title('Phase Space Evolution')
        ax7.grid(True, alpha=0.3)
        ax7.axhline(y=0, color='r', linestyle='--', alpha=0.7)
        ax7.axvline(x=0, color='r', linestyle='--', alpha=0.7)

        # Plot 8: Steady-state analysis (M* vs M)
        ax8 = fig.add_subplot(gs[2, 1])
        m_star = [M_values[i] + mstar_min_m[i] for i in range(len(M_values))]
        ax8.plot(M_values, m_star, 'b-', linewidth=2, label='M*')
        ax8.plot(M_values, M_values, 'r--', linewidth=2, label='M (diagonal)')
        ax8.set_xlabel('M (Nuclear Polarization)')
        ax8.set_ylabel('M* (Target Polarization)')
        ax8.set_title('Steady State Analysis')
        ax8.legend()
        ax8.grid(True, alpha=0.3)

        plt.suptitle('Optical Pumping Simulation Results - Helium-3', fontsize=16, fontweight='bold')

        if save_plots:
            plot_file = os.path.join(output_path, 'optical_pumping_results.png')
            plt.savefig(plot_file, dpi=300, bbox_inches='tight')
            print(f"Plots saved to {plot_file}")

            # Also save individual plots for detailed analysis
            self._save_individual_plots(M_values, mstar_min_m, mdot, a_coeffs,
                                        tpump, abspercm, qe_clean, output_path)

        plt.show()

    def _save_individual_plots(self, M_values, mstar_min_m, mdot, a_coeffs,
                               tpump, abspercm, qe, output_path):
        """Save individual plots for detailed analysis"""

        # Polarization buildup plot
        plt.figure(figsize=(8, 6))
        plt.plot(M_values, mstar_min_m, 'b-', linewidth=2)
        plt.xlabel('M (Nuclear Polarization)', fontsize=12)
        plt.ylabel('M* - M', fontsize=12)
        plt.title('Nuclear Polarization Buildup', fontsize=14, fontweight='bold')
        plt.grid(True, alpha=0.3)
        plt.axhline(y=0, color='k', linestyle='--', alpha=0.5)
        plt.tight_layout()
        plt.savefig(os.path.join(output_path, 'polarization_buildup.png'), dpi=300, bbox_inches='tight')
        plt.close()

        # Population distribution plot
        plt.figure(figsize=(10, 6))
        colors = ['blue', 'red', 'green', 'orange', 'purple', 'brown']
        for i, (label, values) in enumerate(a_coeffs.items()):
            plt.plot(M_values, values, color=colors[i], label=label, linewidth=2)
        plt.xlabel('M (Nuclear Polarization)', fontsize=12)
        plt.ylabel('Population Coefficients', fontsize=12)
        plt.title('Sublevel Population Distribution', fontsize=14, fontweight='bold')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.savefig(os.path.join(output_path, 'population_distribution.png'), dpi=300, bbox_inches='tight')
        plt.close()

        # Optical properties plot
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

        ax1.plot(M_values, tpump, 'g-', linewidth=2)
        ax1.set_xlabel('M (Nuclear Polarization)')
        ax1.set_ylabel('Pump Transmission')
        ax1.set_title('Laser Transmission')
        ax1.grid(True, alpha=0.3)
        ax1.set_ylim(0, 1)

        ax2.semilogy(M_values, np.maximum(abspercm, 1e-10), 'c-', linewidth=2)
        ax2.set_xlabel('M (Nuclear Polarization)')
        ax2.set_ylabel('Absorption Coefficient (cm⁻¹)')
        ax2.set_title('Optical Absorption')
        ax2.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.savefig(os.path.join(output_path, 'optical_properties.png'), dpi=300, bbox_inches='tight')
        plt.close()

        print("Individual plots saved successfully.")

    def create_interactive_plot(self, results):
        """
        Create an interactive plot using matplotlib widgets (if available)
        """
        try:
            from matplotlib.widgets import RadioButtons, Slider
        except ImportError:
            print("Interactive plotting requires matplotlib widgets. Showing static plots instead.")
            self.plot_results(results, save_plots=False)
            return

        if not results:
            print("No results to plot")
            return

        # Extract data
        M_values = np.array([r['M'] for r in results])
        data_dict = {
            'M* - M': np.array([r['MstarminM'] for r in results]),
            'Polarization Rate': np.array([r['Mdot'] for r in results]),
            'Transmission': np.array([r['Tpump'] for r in results]),
            'Absorption': np.array([max(r['abspercm'], 1e-10) for r in results]),
            'Quantum Efficiency': np.array(
                [r['QE'] if np.isfinite(r['QE']) and abs(r['QE']) < 1e10 else 0 for r in results])
        }

        fig, ax = plt.subplots(figsize=(12, 8))
        plt.subplots_adjust(left=0.3, bottom=0.25)

        # Initial plot
        current_key = 'M* - M'
        line, = ax.plot(M_values, data_dict[current_key], 'b-', linewidth=2)
        ax.set_xlabel('M (Nuclear Polarization)')
        ax.set_ylabel(current_key)
        ax.set_title(f'Interactive Plot: {current_key}')
        ax.grid(True, alpha=0.3)

        # Radio buttons for different quantities
        rax = plt.axes([0.05, 0.4, 0.15, 0.3])
        radio = RadioButtons(rax, list(data_dict.keys()))

        def update_plot(label):
            nonlocal current_key
            current_key = label
            y_data = data_dict[label]
            line.set_ydata(y_data)
            ax.set_ylabel(label)
            ax.set_title(f'Interactive Plot: {label}')

            # Update y-axis limits
            if label == 'Absorption':
                ax.set_yscale('log')
            else:
                ax.set_yscale('linear')

            ax.relim()
            ax.autoscale_view()
            plt.draw()

        radio.on_clicked(update_plot)

        plt.show()


def main():
    """Main function to run the optical pumping simulation"""
    simulation = OpticalPumpingSimulation()

    input_path = "./"
    output_path = "./output"
    results = simulation.run_simulation(input_path=input_path, output_path=output_path)
    print("Simulation completed successfully.")
    simulation.plot_results(results, save_plots=True, output_path=output_path)

    # Ask user if they want to see interactive plots
    try:
        user_input = input("\nView interactive plots? (y/n): ").lower().strip()
        if user_input in ['y', 'yes']:
            print("Opening interactive plot viewer...")
            simulation.create_interactive_plot(results)
        else:
            print("Interactive plots skipped.")
    except (EOFError, KeyboardInterrupt):
        print("\nInteractive plots skipped.")

    print("All plotting completed.")

if __name__ == "__main__":
    main()